# -*- coding: utf-8 -*-
"""Day5_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vd1gqnymLlC0qmHUDmylWhpEK9NITK1r
"""

#graph
class Edge:
    def init(self, start: str, end: str):
        self.start: str = start
        self.end: str = end
        # self.weight: int = weight


class Graph:

    def __init__(self):
        self.adjacency_list: list = []

    def insert(self, start: str, end: str):

        isThere: bool = False
        index: int = -1
        for i in range(len(self.adjacency_list)):
            for j in self.adjacency_list[i]:
                if j and j.start == start:
                    isThere = True
                    index = i
                    break

        if isThere and index != -1:
            self.adjacency_list[index].append(Edge(start, end))
        else:
            self.adjacency_list.append([Edge(start, end)])
    def display(self):
        for i in self.adjacency_list:
            for j in i:
                print("( ", j.start, " , ", j.end, " )", end="\t")
            print()


if __name__ == 'main':
    graph: Graph = Graph()

    graph.insert("1","2")
    graph.insert("1","5")
    graph.insert("1","4")
    graph.insert("3","2")
    graph.insert("2","5")
    graph.display()

#avl
class node:
    def __init__(self,value):
        self.data = value
        self.left = None
        self.right = None
        self.height = 1

class AVLTree(object):

    def insert(self,root,value):
        if root == None:
            return node(value)
        if(value<root.data):
            root.left = self.insert(root.left,value)
        elif value>root.data:
            root.right = self.insert(root.right,value)

        root.height = 1 + max(self.ght(root.left),
                              self.ght(root.right))


        bl = self.bal(root)

        if bl > 1 and value < root.left.data:
            return self.leftrotate(root)

        if bl > 1 and value > root.left.data:
            root.left = self.rightrotate(root.left)
            return self.leftrotate(root)

        if bl < -1 and value > root.right.data:
            return self.rightrotate(root)

        if bl < -1 and value < root.right.data:
            root.right = self.leftrotate(root.right)
            return self.rightrotate(root)
        return root

    def ght(self,root):
        if root == None:
            return 0
        return root.height

    def bal(self,root):
        if root == None:
            return 0
        return self.ght(root.left)-self.ght(root.right)

    def leftrotate(self,A):
        if A is None or A.left is None:
            return A
        B = A.left
        temp = B.right
        B.right = A
        A.left = temp

        A.height = 1 + max(self.ght(A.left),
                              self.ght(A.right))
        B.height = 1 + max(self.ght(B.left),
                              self.ght(B.right))
        return B

    def rightrotate(self,A):
        if A is None or A.right is None:
            return A
        B = A.right
        temp = B.left
        B.left = A
        A.right = temp

        A.height = 1 + max(self.ght(A.left),
                              self.ght(A.right))
        B.height = 1 + max(self.ght(B.left),
                              self.ght(B.right))
        return B

    def inorder(self,root):
        if root == None:
            return
        self.inorder(root.left)
        print(root.data, end=" ")
        self.inorder(root.right)


tree = AVLTree()

root = None
V_L = [50 , 36, 12, 20, 76, 18, 44, 52, 90, 100,12,32,44,22,44,65,45,87,65,90,24]
for x in V_L:
    root = tree.insert(root,x)

print(root)

tree.inorder(root)