# -*- coding: utf-8 -*-
"""treaurehunt_coinprblm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11D7GHSUNfSnXjAohVpR-q6mKlB4gdLIw
"""

def longest_zero_sum_subarray(arr):
    max_length = 0
    sum_dict = {}
    curr_sum = 0

    for i in range(len(arr)):
        curr_sum += arr[i]

        if arr[i] == 0 and max_length == 0:
            max_length = 1

        if curr_sum == 0:
            max_length = i + 1

        if curr_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[curr_sum])
        else:
            sum_dict[curr_sum] = i

    return max_length

# Example usage:
arr = [15, -2, 2, -8, 1, 7, 10, 23]
print("Length of the longest subarray with sum zero:", longest_zero_sum_subarray(arr))

#treaure hunt

def max_treasure_locations(locations, compass_range):
    max_locations = 0
    n = len(locations)

    for i in range(n):
        # Define the window boundaries
        left = max(0, i - compass_range)
        right = min(n - 1, i + compass_range)

        # Count the number of locations within the window
        num_locations = right - left + 1

        # Update the maximum number of locations
        max_locations = max(max_locations, num_locations)

    return max_locations

# Example usage:
locations = [1, 0, 0, 1, 1, 0, 1, 0, 1]
compass_range = 2
print("Maximum number of locations where the treasure could be hidden:", max_treasure_locations(locations, compass_range))

#coin problem
def optimal_strategy(coins):
    n = len(coins)
    # Create a 2D table to store the maximum possible value that can be collected
    dp = [[0] * n for _ in range(n)]

    # Fill the diagonal elements of the table with the coin values
    for i in range(n):
        dp[i][i] = coins[i]

    # Iterate over the table to fill in the values using dynamic programming
    for gap in range(1, n):
        for i in range(n - gap):
            j = i + gap
            # When it's player 1's turn, they can choose either the ith or jth coin
            # Player 1 wants to maximize their score, so they choose the maximum of the two options
            dp[i][j] = max(coins[i] - dp[i + 1][j], coins[j] - dp[i][j - 1])

    # If the value at dp[0][n-1] is greater than or equal to zero, the first player wins
    # Otherwise, the second player wins
    if dp[0][n - 1] >= 0:
        return "First player wins."
    else:
        return "Second player wins."

# Example usage:
coins = [18, 20, 15, 30, 10, 14]
print(optimal_strategy(coins))S